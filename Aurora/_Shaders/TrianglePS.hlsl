#include "Globals.hlsli"
#include "Constants.hlsli"

TextureCube tex : register(t1);

// Outputs from vertex shader go here. Can be interpolated to pixel shader.
struct vs_out
{
    float4 outPosition : SV_POSITION; // The position is identified by the SV_POSITION semantic.

    float2 outTexCoord : TEXCOORD;
    float3 outNormal   : NORMAL;
    float3 outWorldSpace : WORLD_POSITION;
};

struct PS_Output
{
    float4 colorOutput : SV_Target0;
    float4 brightColorOutput : SV_Target1;
};

Texture2D objectTexture : TEXTURE: register(t0);
Texture2D bloomBlur : TEXTURE: register(t1);
SamplerState objectSamplerState : SAMPLER: register(s0);

// Attenuation = 1 / Constant + Linear Decrease (Distance) + Exponential (Distance Squared)

PS_Output main(vs_out input) : SV_TARGET // Pixel shader entry point which must return a float4 RGBA color value. 
{
    PS_Output psOutput;

    // Normal Map? Replace the normal variable below and multiply.
    // Roughness Map? Replace our roughness variable, but multiply with it.
    // Metalness Map? Replace our metalness variable, but multiply with it.
    
    // ======
    float3 normalVector = normalize(input.outNormal);
    float3 pixelWorldPosition = input.outWorldSpace;
    float3 viewDirection = normalize(g_Camera_Position.xyz - pixelWorldPosition);

    float3 albedoColor = objectTexture.SampleLevel(objectSamplerState, input.outTexCoord, 0) * g_Material.g_ObjectColor;
    float roughness = g_Material.g_Roughness;
    float metalness = g_Material.g_Metalness;

    // Reflectance Equation
    float3 F0 = float3(0.04, 0.04, 0.04); // Precompute Freshnel for both dieletrics and conductors so the same Fresnel-Schlick approximation can be used for both. Read!
    F0 = lerp(F0, albedoColor, metalness);

    float3 Lo = float3(0.0f, 0.0f, 0.0f); // Total irradiance generated by our light sources.

    for (int i = 0; i < 1; i++)
    {
       // Calculate per-light radiance.
        float3 lightDirection = normalize(g_Light_Position[i].xyz - pixelWorldPosition);
        float3 halfwayVector = normalize(viewDirection + lightDirection);
        float distance = length(g_Light_Position[i] - pixelWorldPosition);
        float attenuation = 1.0 / (distance * distance);
        float3 radiance = g_Light_Color[i] * attenuation;

        // Cook-Torrace BRDF
        float NDF = DistributionGGX(normalVector, halfwayVector, roughness);
        float G = GeometrySmith(normalVector, viewDirection, lightDirection, roughness);
        float3 F = FresnelSchlick(max(dot(halfwayVector, viewDirection), 0.0), F0);

        // Energy Conservation
        float3 kSpecular = F; // The amount of light that gets reflected.
        float3 kDiffuse = float3(1.0, 1.0, 1.0) - kSpecular; // The remaining light energy that gets refracted.
        kDiffuse *= 1.0 - metalness; // As metallic surfaces don't refract light and have no diffuse reflections, we enforce this by nullying kDiffuse if the surface is metallic. 

        // Final BRDF Computation
        float3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(normalVector, viewDirection), 0.0) * max(dot(normalVector, lightDirection), 0.0);
        float3 specular = numerator / max(denominator, 0.001); // We clamp this to 0.001 to prevent any division by zero.

        float NDotL = max(dot(normalVector, lightDirection), 0.0); // Scale light by NDotL.

        // Add to outgoing radiance Lo.
        Lo += (kDiffuse * albedoColor / PI + specular) * radiance * NDotL; // Reflectance Equation.
    }

    float3 finalColor = float3(0.03, 0.03, 0.03) * Lo; // Our ambient is currently a constant factor. For IBL, we will take this into account.

    // Reinhard Tone Mapping
    const float gammaCorrectionFactor = 2.2;
    finalColor = finalColor / (finalColor + float3(1.0, 1.0, 1.0));
    finalColor = pow(finalColor, float3(1.0 / gammaCorrectionFactor, 1.0 / gammaCorrectionFactor, 1.0 / gammaCorrectionFactor));

    // Return to main.
    psOutput.colorOutput = float4(finalColor, 1.0); 
    
    // Check whether fragment output is higher than a threadshold, if so output into our bloom buffer.
    float brightness = dot(finalColor, float3(0.2126, 0.7152, 0.0722));
    if (brightness > 1.0)
    {
        psOutput.brightColorOutput = float4(psOutput.colorOutput);
    }
    else
    {
        psOutput.brightColorOutput = float4(0.0, 0.0, 0.0, 1.0);
    }

    return psOutput;
}